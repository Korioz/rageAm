//
// File: commands_2699_16.h
//
// Copyright (C) 2023 ranstar74. All rights violated.
//
// Part of "Rage Am" Research Project.
//
#pragma once

// THIS FILE IS AUTOGENERATED

#include "../script.h"
#include "../types.h"

// TODO: GET_ENTITY_MATRIX

inline void scrDisableAllControlActions(scrControlType control)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x58699da34f83b510);
	scrValue params[1];
	params[0].Int = control;
	scrInfo info;
	info.ResultPtr = nullptr;
	info.ParamCount = 1;
	info.Params = params;
	s_Handler(info);
}

inline void scrRequestScript(ConstString scriptName)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0xaf76a37c80efd1d8);
	scrValue params[1];
	params[0].String = scriptName;
	scrInfo info;
	info.ResultPtr = nullptr;
	info.ParamCount = 1;
	info.Params = params;
	s_Handler(info);
}

inline scrThreadId scrStartNewScript(ConstString scriptName, int stackSize = 0)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0xe81651ad79516e48);
	scrThreadId result;
	scrValue params[2];
	params[0].String = scriptName;
	params[1].Int = stackSize;
	scrInfo info;
	info.ResultPtr = (scrValue*)&result;
	info.ParamCount = 2;
	info.Params = params;
	s_Handler(info);
	return result;
}

inline void scrTerminateThread(scrThreadId threadId)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x5b71484d4dac41e5);
	scrValue params[1];
	params[0].Int = threadId.Get();
	scrInfo info;
	info.ResultPtr = nullptr;
	info.ParamCount = 1;
	info.Params = params;
	s_Handler(info);
}

// Computes square roof of a number
inline float scrSqrt(float f)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x71D93B57D07F9804);
	float result;
	scrValue params[1];
	params[0].Float = f;
	scrInfo info;
	info.ResultPtr = (scrValue*)&result;
	info.ParamCount = 1;
	info.Params = params;
	s_Handler(info);
	return result;
}

/**
 * \brief The command will return TRUE if it finds collision, FALSE if not.
 * Tries to store the Z coordinate of the highest ground below the given point.
 * \param coors -
 * \param returnZ -
 * \param waterAsGround -
 * \param ignoreDistToWaterLevelCheck -
 * \return -
 */
inline bool scrGetGroundZFor3DCoord(const scrVector& coors, float& returnZ, bool waterAsGround = false, bool ignoreDistToWaterLevelCheck = false)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x9cd4cbf2bbe10f00);
	int result;
	scrValue params[6];
	params[0].Float = coors.X;
	params[1].Float = coors.Y;
	params[2].Float = coors.Z;
	params[3].Reference = (scrValue*)&returnZ;
	params[4].Int = waterAsGround;
	params[5].Int = ignoreDistToWaterLevelCheck;
	scrInfo info;
	info.ResultPtr = (scrValue*)&result;
	info.ParamCount = 6;
	info.Params = params;
	s_Handler(info);
	return result;
}

/**
 * \brief Gets the player index for the main player.
 */
inline scrPedIndex scrPlayerGetID()
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0xe2d3d51028f0428a);
	scrPedIndex result;
	scrInfo info;
	info.ResultPtr = (scrValue*)&result;
	info.ParamCount = 0;
	info.Params = nullptr;
	s_Handler(info);
	return result;
}

inline void scrSetPedCoordsKeepVehicle(scrPedIndex pedIndex, const scrVector& newCoors)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0xcb8859434b382fcc);
	scrValue params[4];
	params[0].Int = pedIndex.Get();
	params[1].Float = newCoors.X;
	params[2].Float = newCoors.Y;
	params[3].Float = newCoors.Z;
	scrInfo info;
	info.ResultPtr = nullptr;
	info.ParamCount = 4;
	info.Params = params;
	s_Handler(info);
}

/**
 * \brief Create an object  with an offset (from the root the base) at the given coord.
 * \param model -
 * \param coors -
 * \param registerAsNetworkObject The new object will be created and synced on other machines if a network game is running
 * \param scriptHostObject If true, this object has been created by the host portion of a network script and is vital to that script - it must always exist regardless of who is hosting the script.
 * If false, the object has been created by the client portion of a network script and can be removed when the client who created it leaves the script session.
 * \param forceToBeObject If true, the object will always be forced to be an object type. This applies when creating an object that uses a door model. If this is false the object will be created as a door door type.
 * \return -
 */
inline scrObjectIndex scrCreateObject(u32 model, scrVector coors, bool registerAsNetworkObject = true, bool scriptHostObject = true, bool forceToBeObject = false)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x0e536d72ab30f4c8);
	scrObjectIndex result;
	scrValue params[7];
	params[0].Uns = model;
	params[1].Float = coors.X;
	params[2].Float = coors.Y;
	params[3].Float = coors.Z;
	params[4].Int = registerAsNetworkObject;
	params[5].Int = scriptHostObject;
	params[6].Int = forceToBeObject;
	scrInfo info;
	info.ResultPtr = (scrValue*)&result;
	info.ParamCount = 7;
	info.Params = params;
	s_Handler(info);
	return result;
}

inline void scrDeleteObject(scrObjectIndex& index)
{
	using namespace rageam::integration;
	static scrSignature s_Handler = scrLookupHandler(0x4bda5afd88c085eb);
	scrValue params[1];
	params[0].Reference = (scrValue*)&index;
	scrInfo info;
	info.ResultPtr = nullptr;
	info.ParamCount = 1;
	info.Params = params;
	s_Handler(info);
}
